# CREAM/AMP Reentrancy Attack

## What happened?

On August 31st, 2021, an attacker stole 19.6 million dollars worth of ETH and AMP from Cream lending pools. This attack was notable because it was a successful reentrancy attack against contracts that did have reentrancy protection.## What is a reentrancy attack?The very first big hack on an Ethereum smart contract was a reentrancy attack.  Reentrancy attacks are THE classic Ethereum smart contract vulnerability.Consider a sample bank smart contract with this withdrawn method:```javascriptwithdraw(address user, uint256 amount){  // Check
  uint256 oldBalance = balances[user];  require(oldBalance > amount);  // Calculate  uint256 newBalance = oldBalance - amount;  // Transfer funds  coin.transfer(user, amount);  // Store  balances[user] = newBalance; }```If an attacker was able to run their own code during the coin transfer, then the attacker could withdraw more than they had deposited. Let’s see how this works.The attacker starts with $1,000 deposited, and requests a withdrawal of $1,000. The withdrawal function reads in the user’s balance, checks that the user has funds, and sets a temporary variable newBalance to $0. The “newBalance” variable isn’t a write to storage, it’s just inside the execution of the function.
When the $1,000 is transferred to the attacker, the attacker gets to run code right there in the middle of the withdraw function. Immediately, the attacker requests another withdrawal for $1,000. Because the storage keeping track of the user’s balance has not yet been updated, the withdrawal functions loads in the user’s balance as still $1,000 and permits another withdrawal to begin.

After the second transfer in the second withdraw is complete, then the newBalance in each running copy of the withdrawal function are stored. In each case, the newBalance being stored would be zero. The attacker has doubled their money, and could repeat the attack.

## AMP Background

The AMP ERC20 token is special. A core part of the AMP token implementation is that during each transfer of AMP from one user to another, the token can run external code chosen by the receiver. This is very unusual, and allows code to be run in the middle of other contracts being executed. This is a classic opening for a reentrancy attack.

## Cream Background

Cream is a set of over-collateralized lending pools, like Compound and AAVE. A user deposits an amount of a crypto token, and is then able to borrow a smaller dollar value of a different crypto token.

A core part of the protocol is that a user can never borrow a greater amount than the user's collateral permits. To calculate this, before making a loan, the Cream codebase scans through each lending pool in the system to verify how much the user has borrowed from each and lent to each.
## Cream Borrow Function

The CREAM borrow function looks like this (focusing just on the user balance and the transfer):
```javascriptfunction borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
  // …
  vars.accountBorrows = borrowBalanceStoredInternal(borrower);
  vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);
  // …
  doTransferOut(borrower, borrowAmount);
  /* We write the previously calculated values into storage */
  accountBorrows[borrower].principal = vars.accountBorrowsNew;
  // …
}
```

It looks exactly like a textbook reentrancy example. So why wasn’t it hacked long  before?

## Reentrancy Defenses

There are three common reentrancy defenses that smart contracts use.

### 1. External function calls last

If we jump back to our example, but move just one line of code, we can prevent a reentrancy attack:

```javascriptwithdraw(address user, uint256 amount){  // Check
  uint256 oldBalance = balances[user];  require(oldBalance > amount);  // Calculate  uint256 newBalance = oldBalance - amount;  // Store  balances[user] = newBalance; // MOVED to before transfer
  // Transfer funds  coin.transfer(user, amount);}```

If the call to an external function is after everything else in the function, then the attacker gains no advantage by calling the code from inside the transfer. This simple method of preventing attacks was learned painfully in the early days of Ethereum, and  this defense is in the official Solidity documentation.

### 2. NonReentrant locks

But sometimes you need to make multiple external calls, or there are unavoidable calculations that must be done after external calls. In such a case, the usual solution is to use a single contract storage slot as a lock. Whenever any state changing function in the contract is called, the lock storage is checked. If it's locked, the function will revert. If it is unlocked, then the function will write a locked value to the storage and continue normal execution. As the last step in its code the function will unlock the lock. This prevents an attacker from executing code in the same function twice.

NonReentrant locks are incredibly common, and are essentially standard for smart contracts these days. It's a simple tool that prevents a tremendous amount of mischief.

### 3. Only using trusted external coins

Lastly, a common method is to have a whitelist of trusted coins or contracts that your own contract is allowed to interact with. As long as these external contract are not attacking you themselves, and not calling out to external contracts themselves in methods you use, this can be safe.

But it's very easy to get wrong. Either in forgetting to check somewhere inside your code that a coin is in your list before calling it, or in adding a trusted coin and not checking it for reentrancy possibilities. Lastly a coin that was safe before could potentially be upgraded later to unsafe behavior.

## How did the CREAM attack work?

As we already saw, the order of the CREAM borrow function was vulnerable to reentrancy. Furthermore, a coin that allowed calling external, attacker controlled code was added to the list of tokens supported by CREAM.

However, the CREAM lending pool contracts did have reentrancy locks on their contract functions. How did the contracts get hacked when they had protection for this.

The CREAM lending system is made up of multiple contracts with one "CToken" pool token for each asset supported. ETH has a contract, as does USDC, as does AMP, etc. Each one of these individual lending contracts has its own separate lock for protecting that individual contract against reentrancy. 

However, the system *as a whole* is not protected because an attacker could be inside different lending pool contracts simultaneously. In this attack, the attacker put up one an a half million dollars of collateral, then borrowed AMP. During the borrow function for in the AMP pool contract, the AMP coin called the attackers code, allowing the attacker to start a second borrow of ETH. Because the AMP borrow had not written any record of the AMP borrow to storage yet, when the ETH borrow in the ETH pool contract checked with all pool contracts to see how much the attacker had already borrowed, it saw that the attacker had lots of collateral and no debts, and thus allowed the ETH borrow.

The [Cream Post Mortem](https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5) has an excellent writeup of the rest of the attack, beyond the core vulnerability.

## Catching this kind of vulnerability

- The slither automated tool will check individual functions for state writes after external calls.
- Contract level reentrancy protection should be used unless you have an extremely simple contract that can be proven not to need it.
- If you have an interlocking set of contracts, you might need either a global level of locking, or a way to funnel incoming transactions through a single contract.
- As DeFi gets more complicated, there may be more reentrancy vulnerabilities found involving contracts from multiple parties, each individually protected, but systematically weak.

## Links

- [An attack transaction](https://ethtx.info/mainnet/0xa9a1b8ea288eb9ad315088f17f7c7386b9989c95b4d13c81b69d5ddad7ffe61e/)
- [CREAM CToken contract code](https://etherscan.io/address/0x3c710b981f5ef28da1807ce7ed3f2a28580e0754#code)
- [AMP token code](https://etherscan.io/address/0xff20817765cb7f73d4bde2e66e067e58d11095c2#code)
- [Cream Post Mortem](https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5)